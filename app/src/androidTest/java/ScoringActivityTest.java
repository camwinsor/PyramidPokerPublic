import android.app.Instrumentation;
import android.content.Intent;
import android.os.SystemClock;
import android.support.test.rule.ActivityTestRule;
import android.support.test.runner.AndroidJUnit4;
import android.test.AndroidTestCase;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import javax.inject.Singleton;

import cwins.cardgame.FlashPokerApplication;
import cwins.cardgame.GamesListActivity;
import cwins.cardgame.MainActivity;
import cwins.cardgame.MenuActivity;
import cwins.cardgame.R;
import cwins.cardgame.ScoringActivity;
import dagger.Component;

import static android.support.test.InstrumentationRegistry.getInstrumentation;
import static android.support.test.espresso.Espresso.onView;
import static android.support.test.espresso.assertion.ViewAssertions.matches;
import static android.support.test.espresso.matcher.ViewMatchers.withId;
import static android.support.test.espresso.matcher.ViewMatchers.withText;

@RunWith(AndroidJUnit4.class)
public class ScoringActivityTest extends AndroidTestCase {
    /**
     * This is our mock component. We inherit from the normal production component,
     * FlashPokerApplication.ApplicationComponent, in order to use MockComponent
     * where we'd normally use ApplicationComponent.
     */
    @Singleton
    @Component(modules = MockModule.class)
    public interface MockComponent extends FlashPokerApplication.ApplicationComponent {
        void inject(FlashPokerApplication application);
        void inject(MenuActivity menuActivity);
        void inject(ScoringActivity scoringActivity);
        void inject(GamesListActivity gamesListActivity);
        void inject(MainActivity mainActivity);
    }

    /**
     * ActivityTestRule comes from Espresso. Unit test code can't actually
     * create Activity objects from scratch (unlike normal classes, where we can just invoke the
     * constructor), so Espresso has these ActivityTestRules that do all the android-specific
     * work that's required to initialize and run Activities.
     */
    @Rule
    public ActivityTestRule<ScoringActivity> mActivityRule = new ActivityTestRule<>(
            ScoringActivity.class,
            true,
            false);

    @Before
    public void setUp() {
        // just some trickery to get our app's Application object
        Instrumentation instrumentation = getInstrumentation();
        FlashPokerApplication app = (FlashPokerApplication) instrumentation.getTargetContext()
                .getApplicationContext();

        // the important bit: we create a new "injector" that gets its dependencies from
        // our MockModule instead of the real Modules. DaggerScoringActivityTest_MockComponent
        // is a class that's automatically generated by dagger based on the interface we
        // defined above (MockComponent)
        MockComponent testComponent = DaggerScoringActivityTest_MockComponent.builder()
                .mockModule(new MockModule())
                .build();

        // configures the entire app to use our bogo injector instead of the normal one.
        // (the normal one is DaggerFlashPokerApplication_ApplicationComponent, which is
        // defined in FlashPokerApplication.java)
        app.setComponent(testComponent);
    }

    @Test
    public void changeText_sameActivity() {


//        // Type text and then press the button.
//        onView(withId(R.id.opponent_name))
//                .perform(typeText(mStringToBetyped), closeSoftKeyboard());
//        onView(withId(R.id.changeTextBt)).perform(click());


        mActivityRule.launchActivity(new Intent());

        SystemClock.sleep(80000);

        // Check that the text was changed.
        onView(withId(R.id.user_name))
                .check(matches(withText("foobar")));


    }
}
